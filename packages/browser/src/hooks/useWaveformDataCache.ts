/**
 * useWaveformDataCache
 *
 * Manages a Map<clipId, WaveformData> that stores pre-computed WaveformData
 * objects generated by a web worker. These enable near-instant zoom changes
 * via WaveformData.resample() instead of re-scanning raw audio samples.
 *
 * Behavior:
 * - Creates the worker lazily on first clip needing generation
 * - Tracks submitted clip IDs via ref to avoid duplicate worker jobs
 * - Uses a cancelled flag to ignore responses after effect cleanup
 * - Terminates the worker on unmount
 */

import { useState, useEffect, useRef, useCallback } from 'react';
import type { ClipTrack } from '@waveform-playlist/core';
import type WaveformData from 'waveform-data';
import { createPeaksWorker, type PeaksWorkerApi } from '../workers/peaksWorker';

export interface UseWaveformDataCacheReturn {
  cache: ReadonlyMap<string, WaveformData>;
  isGenerating: boolean;
}

export function useWaveformDataCache(
  tracks: ClipTrack[],
  baseScale: number,
): UseWaveformDataCacheReturn {
  const [cache, setCache] = useState<Map<string, WaveformData>>(() => new Map());
  const [isGenerating, setIsGenerating] = useState(false);

  const workerRef = useRef<PeaksWorkerApi | null>(null);
  const submittedRef = useRef<Set<string>>(new Set());
  const pendingCountRef = useRef(0);

  // Stable callback to get or create the worker
  const getWorker = useCallback(() => {
    if (!workerRef.current) {
      workerRef.current = createPeaksWorker();
    }
    return workerRef.current;
  }, []);

  useEffect(() => {
    let cancelled = false;
    const submitted = submittedRef.current;

    // Find clips that have audioBuffer but no waveformData and haven't been submitted
    const clipsToProcess: { clipId: string; audioBuffer: AudioBuffer }[] = [];

    for (const track of tracks) {
      for (const clip of track.clips) {
        if (
          clip.audioBuffer &&
          !clip.waveformData &&
          !submitted.has(clip.id)
        ) {
          clipsToProcess.push({
            clipId: clip.id,
            audioBuffer: clip.audioBuffer,
          });
        }
      }
    }

    if (clipsToProcess.length === 0) return;

    // Mark all as submitted before starting async work
    const submittedThisRun = new Set<string>();
    for (const { clipId } of clipsToProcess) {
      submitted.add(clipId);
      submittedThisRun.add(clipId);
    }

    pendingCountRef.current += clipsToProcess.length;
    setIsGenerating(true);

    const worker = getWorker();

    for (const { clipId, audioBuffer } of clipsToProcess) {
      // .slice() channel buffers to avoid detaching the original AudioBuffer views
      const channels: ArrayBuffer[] = [];
      for (let c = 0; c < audioBuffer.numberOfChannels; c++) {
        channels.push(audioBuffer.getChannelData(c).slice().buffer);
      }

      worker
        .generate({
          id: clipId,
          channels,
          length: audioBuffer.length,
          sampleRate: audioBuffer.sampleRate,
          scale: baseScale,
          bits: 16,
          splitChannels: true,
        })
        .then((waveformData) => {
          if (cancelled) return;

          setCache((prev) => {
            const next = new Map(prev);
            next.set(clipId, waveformData);
            return next;
          });

          pendingCountRef.current--;
          if (pendingCountRef.current <= 0) {
            pendingCountRef.current = 0;
            setIsGenerating(false);
          }
        })
        .catch((err) => {
          if (cancelled) return;
          console.warn('[waveform-playlist] Worker peak generation failed:', err);
          // Remove from submitted so it can be retried on next effect run
          submitted.delete(clipId);
          pendingCountRef.current--;
          if (pendingCountRef.current <= 0) {
            pendingCountRef.current = 0;
            setIsGenerating(false);
          }
        });
    }

    return () => {
      cancelled = true;
      // Clear IDs submitted by this effect run so they can be resubmitted
      // if the effect re-runs with new deps (e.g., tracks changed)
      for (const clipId of submittedThisRun) {
        submitted.delete(clipId);
      }
    };
    // submittedRef guards against duplicate submissions â€” no need for cache in deps
  }, [tracks, baseScale, getWorker]);

  // Terminate worker on unmount
  useEffect(() => {
    return () => {
      workerRef.current?.terminate();
      workerRef.current = null;
    };
  }, []);

  return { cache, isGenerating };
}
